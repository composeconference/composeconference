{ "times": [
  { "time": "8:30am" , "name": "<hr />" , "id": "t-8300", "title": "Registration", "break": true},

  { "time": "9:00am" ,
    "name": "Lyndon Maydwell" ,
    "id": "introduction",
    "title": "Introduction by the Committee",
    "details": "Welcome to Compose :: Melbourne!",
    "committee": true},

  { "time": "9:30am" ,
    "name": "Andrew Sorensen" ,
    "id": "andrew_sorensen",
    "title": "Keynote - Sound Synthesis in the Computational Crucible",
    "permalink": "/2017-melbourne/speaker-andrew-sorensen",
    "level": 1, 
    "img": "/assets/img/2017-melbourne/andrew_sorensen.jpg",
    "details": "
    <p>A crucible allows base metals to be mixed together at high temperatures to form alloys.
    Medieval alchemists used crucibles to mix an astonishing variety of substances together
    in the search for new materials. While Alchemy is often derided for its informal approach,
    early Alchemists paved the wave for modern chemistry, and included Newton and
    Boyle among their number.</p>
    <p>Just as the crucible encouraged an experimental and experiential approach to
    understanding the world, so too the computer can provide a computational crucible.
    Code can be mixed and brought to great temperature in the search for greater
    understanding and new discovery.</p>
    <p>Using his own Extempore programming language Andrew will provide a 'live' introduction
    to sound synthesis, building up the core components of a real-time digital synthesizer
    on-the-fly 'in the computational crucible'.</p>
    ",
    "bio": "
    <p>
    Andrew Sorensen is an artist, a programmer, and a computer scientist. His interests are diverse, but unify under a common theme
    - the programming language as an interface for real-time dialogue between human, machine, and environment. In exploring these
    ideas Andrew is as likely to be found hacking code in nightclubs as steering scientific codes on distributed high performance
    computing clusters.  Andrew is well known for creating the programming languages that he uses in live performance to generate
    audiovisual theatre. He is the author of the Extempore programming language - a systems programming language designed for
    high-performance 'live' programming.</p>
    "
  },
  {"time": "10:15am",
    "title": "Break",
    "name": "<hr />",
    "id": "break1",
    "break": true},
  {"time": "10:30",
    "name": "Andrew McCluskey",
    "id": "andrew_mccluskey",
    "img": "/assets/img/2017-melbourne/andrew_mccluskey.jpg",
    "permalink": "/2017-melbourne/speaker-andrew-mccluskey",
    "title": "Your first Haskell app",
    "level": 1, 
    "bio": "
      Andrew is a functional programming engineer at Data61. Earlier in his career he worked across a range of domains 
      using conventional imperative programming languages, growing more and more frustrated with the difficulties 
      of reasoning in a stateful and often untyped world. After hearing the claims that functional programming offered 
      solutions to these problems, he embarked on learning Clojure - having fond memories of his first year programming 
      course in Scheme. Convinced that FP was a good choice, but being burned by a lack of types, Andrew then 
      switched his focus to Haskell and hasn't looked back since.
    ",
    "details": "
      <p>When learning a new programming language there is almost always a leap from learning to applying 
         your knowledge. This leap can be quite large when learning Haskell for a number of reasons. 
         One reason is the dramatic difference between Haskell's style of programming compared to more common 
         imperative languages that many learners are more familiar with. As a consequence, a difficulty for those 
         new to Haskell is identifying when and how to apply the concepts they've learned when writing an 
         application. Another is navigating the Haskell ecosystem; including finding packages and understanding 
         how they work. Finally, some newcomers may delay writing their first application, believing they 
         need to be comfortable with more advanced concepts before they can successfully write useful 
         software. This is not the case. While these abstractions are useful, many of Haskell's benefits 
         can be enjoyed while sticking to its more basic abstractions.</p>

         <p>By referring to a simple example application, we'll demonstrate how and when to apply some 
            core techniques and abstractions, and alleviate the burden of starting an app from scratch. 
            We'll cover a number of data types, type classes, and techniques, including:</p>
         <ul>
	   <li>Effectively using algebraic data types to more precisely model the problem</li>
	   <li>Using applicative parsers to read configuration from the command line or files</li>
	   <li>Using the Monoid type class to merge layers of configuration. e.g. user values merged with defaults</li>
	   <li>Using Maybe in place of null or exceptions to handle missing/optional data</li>
	   <li>Using Either in place of exceptions or return codes to handle failures</li>
	   <li>Using the Monad type class to sequence computations in a particular context, such as IO</li>
         </ul>
         <p>If you've ever been intimidated by the thought of starting a project in Haskell, then this talk will 
            give you a solid place to start. Along the way we'll see that, not only is Haskell a general purpose 
            language that can be used to write everyday applications, but that it brings with it a range of benefits.</p>
    "},
  {"time": "11am",
    "name": "Rahul Trikha",
    "id": "rahul_trikha",
    "img": "/assets/img/2017-melbourne/rahul_trikha.jpg",
    "permalink": "/2017-melbourne/speaker-rahul-trikha",
    "title": "From JavaScript to PureScript",
    "level": 1, 
    "bio": "
      <p>Rahul works as a Technical Lead at REA Group building micro services to power their backend systems. 
         He uses Ruby by day and Haskell/PureScript by night. He enjoys learning more about functional patterns
         and becoming a better dev through applying them in his everyday code.</p>
    ",
    "details": "
      <p>Functional programming techniques have been making appearances in JavaScript for some time now. However, 
         functional programming in JavaScript has some disadvantages: JavaScript is verbose, untyped, and lacks 
         powerful forms of abstraction. Unrestricted JavaScript code also makes equational reasoning very difficult. 
         A functional JavaScript programmer must stay sharp at all times to create pure functions that avoid side effects. 
         However, this puts too much cognitive load on the programmer.</p>

      <p>PureScript, on the other hand, is a Haskell-inspired statically typed language which aims to address these issues. 
         It features lightweight syntax, which allows developers to write very expressive code which is still clear and readable. 
         It uses a rich type system to support powerful abstractions. It also generates fast, understandable JavaScript code, 
         which is important when interoperating with other JavaScript libraries. PureScript strikes a very practical balance 
         between the theoretical power of purely functional programming and the fast-and-loose programming style of JavaScript. </p>

      <p>The idea behind this talk is to encourage developers to build real-world applications using PureScript. 
         I hope to take you through a journey of applying functional patterns to everyday problems so that you 
         can appreciate the simplicity and ideas behind these patterns:</p>
	<ul>
	<li>Algebraic data types and pattern matching</li>
	<li>Row polymorphism and extensible records</li>
	<li>Higher kinded types</li>
	<li>Type classes with functional dependencies</li>
	<li>Higher-rank polymorphism</li> 
	</ul>
    "
  },

  {"time": "11:30am",
    "name": "TBA",
    "id": "tba1",
    "title": "TBA"},

  {"time": "12pm",
    "title": "Lunch",
    "id": "lunch",
    "name": "<hr />",
    "break": true},

  {"time": "1pm",
    "name": "George Wilson",
    "id": "george_wilson",
    "level": 1,
    "permalink": "/2017-melbourne/speaker-george-wilson",
    "title": "Type Class: The Ultimate Ad Hoc",
    "img": "/assets/img/2017-melbourne/george_wilson.jpg",
    "bio": "
      <p>George Wilson is an enthusiastic functional programmer at the <a href='http://qfpl.io'>Queensland Functional Programming Lab</a>, 
         under Data61/CSIRO, located in Brisbane, Australia.</p> 
      <p>George co-organises the Brisbane Functional Programming Group and enjoys teaching and learning functional programming 
         and related areas of mathematics.</p>
    ",
    "details": "
      <p>Since their inception in Haskell, type classes have become a popular 
        feature of modern functional programming. Indeed, key topics in FP often take the form
	of type classes, such as Monoid and Functor. Many languages developed since
	Haskell have included type classes in their design, such as Idris and Purescript;
	or offered facilities capable of simulating type classes, such as Scala's implicits
	or OCaml's modules.</p>
      <p>In this talk we go beyond the basics with type classes. First we'll differentiate
	between parametric and ad hoc polymorphism, and we'll see why type classes
	are a compelling solution to the latter. By comparing them to other solutions
	- Java interfaces and Scala implicits - we'll see the advantages of type classes.
	In particular, we will focus on why type classes are principled. This section will
	include examples in Java, Scala, and Haskell.</p>
	<p>In order to be principled, there are conditions on the creation of instances:
	there can be a maximum of one instance for a given type for a given type class,
	and it must be in one of two allowed places. We will justify this rigidity by
	discussing instance coherence and its benefits, with examples of incoherence
	silently causing bugs. We will learn what orphan instances are and why they
	can be problematic for coherence.</p>
	<p>Finally, practical guidelines will be given for programmers aiming to simulate
	type classes in other languages, as is popular in the Scala community. These
	guidelines, when followed with discipline, will allow one to recover many of the
	benefits of type classes. Examples in this section will be in Scala.</p>
      <h3>Goal</h3>
        <p>Attendees will leave knowing the difference between parametric 
           and ad hoc polymorphism, and they will understand why type classes 
           are a principled approach to the latter. Attendees wishing to simulate 
           type classes in a capable language, such as Scala, will leave the talk 
           with practical guidelines helping them to do so.</p>
    "
   },

  {"time": "1:30pm",
    "name": "Justin Bed&#337;",
    "id": "justin_bedo",
    "permalink": "/2017-melbourne/speaker-justin-bedo",
    "img": "/assets/img/2017-melbourne/justin_bedo.jpg",
    "title": "BioShake: a Haskell EDSL for bioinformatics pipelines",
    "level": 2,
    "details": "
      <p>
      Recently there have been great advances in the field of biology arising
      from rapid technological progress, notably in certain areas such as
      genomics. These technologies have drastically increased the use of
      computing as part of data processing and analysis. It is now common to
      use many hours of compute to process biological data in what is known as
      a *bioinformatics pipeline*.
      </p>
      <p>
      These bioinformatics pipelines are typically composed of numerous
      programs and stages coupled together loosely using intermediate files.
      These pipelines tend to be quite complex and require substantial
      computational time, hence a good pipeline must be able to manage
      intermediate files, guarantee rentrability &mdash; the ability to re-enter and
      continue a partially run pipeline &mdash; and also provide clear syntax to
      easily describe and understand pipelines.
      </p>
      <p>
      This is a problem that resembles the problem of building software
      artefacts that is common in computer science. Some notable tools are the
      ubiquitous tool *make*, and more recently *Shake*, a robust build tool
      implemented as an embedded domain specific language (EDSL) in Haskell.
      However, bioinformatic pipelines have some unique properties that do not
      fit well into current build tools...
      </p>
    ",
    "bio": "
      Dr Justin Bed&#337; is a researcher at the Walter and Eliza Hall institute.
      His interests span machine learning, bioinformatics, privacy, and
      computer science. Justin has researched at several labs and companies:
      NICTA, IBISC (le laboratoire Informatique, Biologie Int&eacute;grative et
      Syst√®mes Complexes), and IBM Research Australia.
    "},
  {"time": "2pm",
    "name": "Tony Morris",
    "id": "tony_morris",
    "permalink": "/2017-melbourne/speaker-tony-morris",
    "img": "/assets/img/2017-melbourne/tony_morris.jpg",
    "title": "FP in Aviation",
    "level": 2, 
    "bio": "
    <p>Tony Morris is a software engineer for the <a href='http://qfpl.io'>Queensland Functional Programming Lab</a>,
    under Data61/CSIRO, located in Brisbane, Australia. Tony has been deploying functional
    programming solutions for over 10 years, using the Haskell and Scala programming
    languages primarily. Tony teaches functional programming at the tertiary level and
    for professional programmers with a view toward producing a viable commercial result.</p>

    <p>Tony takes a fastidious, principled approach to functional programming both when
    deployed in practice and when in a learning environment to ensure maximum yield
    from the effort. Tony believes that exploring principles and the following
    consequences provides a rewarding experience for all involved.</p>
    ",
    "details": "
    <p>In this talk & demo, we have a look at some of the low-hanging problems in general
    aviation and how functional programming can be applied to provide significant
    improvements in efficiency and air safety. The current solutions to problems
    such as navigation, traffic/terrain collision avoidance and weight/balance
    calculations will be demonstrated to the audience, mostly for amusement. More
    seriously, we will have a look at the legacy that has led to the way things are,
    and how to improve by applying our programming skills.</p>

    <p>We will look at:
    <ul>
    <li>How aviation safety is regulated.</li>
    <li>How aeronautical services are provided to flight operators.</li>
    <li>How aeronautical navigation is conducted and regulated.</li>
    <li>How the weight and balance for a flight is conducted.</li>
    <li>The methods by which aircraft and ground coordinate between each other.</li>
    </ul></p>

   <p>We will see:
    <ul>
    <li>Some real (and basic) data management problems in aviation, that very
    obviously threaten safety, then solve them, using programming.</li>
    <li>We will see a live demonstration of aeronautical navigation methods,
    investigate incident reports where lives were lost as a result, and consider
    how our programming skills can yield improvements, possibly even save lives.</li>
    <li>We will conduct a real weight&balance calculation for a flight, then once
    hilarity inevitably ensues, we will look at the problems that arise by this
    method, then solve them using data structures and functional programming. Some
    of these practical problems are obvious, even to a non-aviator, and the
    predictable incident reports are the end result.</li>
    <li>Finally, we will have a look at a live demonstration of a software defined
    radio (SDR), receiving ADS-B transmissions from aircraft (live), an AHRS
    implementation and GNSS receiver using off-the-shelf, low-cost parts. We will
    look at why these instruments are helpful to aircraft pilots and interact with
    that device using the Haskell programming language.</li>
    </ul>
    </p>
    "
  },

  {"time": "2:30pm",
    "title": "Break",
    "name": "<hr />",
    "id": "break2",
    "break": true},

  {"time": "3pm",
    "name": "Ronen Narkis",
    "id": "ronen_narkis",
    "permalink": "/2017-melbourne/speaker-ronen-narkis",
    "title": "Re-ops, a Functional Live-Infrastructure as Code",
    "img": "/assets/img/2017-melbourne/ronen_narkis.jpg",
    "level": 2, 
    "bio": "
    <p>Ronen Narkis has been a pro coder for more than 12 years across a variety of projects
    ranging from Devops to Bigdata, using Clojure since 2008 to solve real world problems.</p>

    <p>He enjoys expanding his knowledge about security, operating systems, programming
    languages and any other cool tech he can lay his hands on.</p>
    ",
    "details": "
	<p>The history of live coding environments isn't new, still most of the current tools we use are static in nature 
           and require long cycles of build/compilation/restart both in development and production, the REPL is one of the 
           most productive environments to get instant feedback and have become the standard for contemporary functional languages.</p>

	<p>In this talk we will go through Re-ops, a Clojure based live environment that aims to speed up remote server 
           management, from ad hoc remote operations to metrics collection/reporting up to managing clusters of virtual machines.</p>

	<p>Current configuration management tools (Puppet/Chef/Ansible) are custom environments running on top of 
           Ruby/Python that don't interact (for the most part) with the hosting platform, Re-ops on the other hand is native 
           Clojure and can use any library and language facility.</p>

	<p>Using function composition, protocols and data structures with a dash of macros we create our own core abstractions,
           matching the lisp philosophy of extending the language to match our needs while keeping it simple to extend and use.</p>

	<p>Re-ops is composed from a number of components:</p>

        <ul>
	<li>Re-core: VM management and tracking (AWS, Digital Ocean, KVM), using async job execution.</li>
	<li>Re-mote, remote operations on systems using SSH and ZeroMQ including data collection, aggregation, dashboarding and scheduling.</li>
	<li>Re-gent, remote agent that uses ZeroMQ and connects back to Re-mote, used for high throughput low latency operations (an alternative to SSH).</li>
	<li>Each can be used separately or combined.</li>
        </ul>

	<p>In summary Re-ops offers an alternative for creating infrastructure as code, one in which we can react quickly to a 
           fast changing environment.</p>

	<p>Goals:</p>

        <ul>
	<li>To expose listeners to a different way of thinking with regards to operations (Devops).</li>
	<li>To showcase how to design a system that works well as a live environment both in Clojure (the reload workflow) and the general case.</li>
	<li>Explore protocols, functional composition and pipelines as a base for rapidly changing system.</li>
	<li>How to design the system for explorability</li>
	<li>Cover some interesting libraries used within Re-ops</li>
	<li>Compare Puppet/Chef and show how using Clojure really simplify some problems.</li>
        </ul>

    "
  },

  {"time": "3:30pm",
    "name": "Luke Stephenson",
    "id": "luke_stephenson",
    "permalink": "/2017-melbourne/speaker-luke-stephenson",
    "img": "/assets/img/2017-melbourne/luke_stephenson.jpg",
    "title": "Reactive Streams for REA feeders",
    "level": 2, 
    "bio": "
    Luke Stephenson works as a Lead Developer at REA Group building Scala services
    to power the consumer facing website.  After many years as a Java developer,
    Luke has enjoyed the transition to Scala and becoming a better dev through many FP learnings.
    ",
    "details": "
    <p>This talk introduces Reactive Streams, specifically the Monix implementation and
    how at REA Group we have used it to solve real problems.</p>

    <p>At REA we have many 'feeders' which extract from one data source, perform some
    processing and transformations before loading into a target system.</p>

    <p>Historically these feeders have been built using Java / Scala concurrency primitives
    (e.g. Future / ExecutionContext).  The typical feeder has a very sequential execution
    model like: <br/>
    <ol>
    <li>Read a batch in parallel from the source system. The reading is done in as a parallel batch because the source system may be slow, e.g. an S3 bucket).</li>
    <li>Transform the batch</li>
    <li>Write the batch in parallel to the target system</li>
    </ol> </p>

    And repeat the above until all data is processed.

    <p>The very sequential nature means the feeds are not as performant as they could be.
    The source and target systems were never accessed in parallel.  Writing to the
    target required waiting for the source to read another batch.  And the feeder
    would not read another batch from the source until the target completed.</p>

    <p>Also being based on lower level concurrency primitives, the data pipeline
    is not as easy to visualise from reading the codebase.</p>

    <p>Reactive streams allow us to model asynchronous processing pipelines as a data
    type which can then be executed.  The APIs are declarative, as opposed to the
    legacy solution working with Scala Future and ExecutionContext which resulted
    in immediate evaluation.</p>

    <p>The talk will cover:
    <ul>
    <li>Background into our feeders and legacy implementation</li>
    <li>How the latency involved in that implementation cumulates to affect performance</li>
    <li>Intro to the Monix reactive streams implementation covering the key APIs that we have used</li>
    <li>Demonstrating how the APIs are just data types and that nothing is executed until the observable is consumed and run.</li>
    <li>Code examples for a basic feeder structure</li>
    <li>How the end solution is more performant, but more importantly that the code is more expressive and easy to reason about.</li>
    </ul>
    </p>

    <p>Attendees should leave with a basic understanding of Reactive Streams, and specifically
    how to get started with the Monix implementation of reactive streams.  I'll share a
    working basic project (not REA production code) which provides a basic 'feeder'
    structure for attendees to reference and extend upon if they wish.</p>
    "
  },

  {"time": "4pm",
    "title": "Break",
    "name": "<hr />",
    "id": "break3",
    "break": true},

  {"time": "4:15pm",
    "name": "Huw Campbell",
    "id": "huw_campbell",
    "permalink": "/2017-melbourne/speaker-huw-campbell",
    "img": "/assets/img/2017-melbourne/huw_campbell.jpg",
    "title": "Grenade - Dependently Typed Neural Networks in Haskell",
    "level": 3, 
    "bio": "
      <p>Huw Campbell is a physicist, data scientist, and functional programmer,
        currently working at Ambiata in Sydney. Coming from an academic
	background with a PhD in experimental physics, Huw started working
	as an applied researcher in machine learning in 2014. With Ambiata's
	broad Haskell experience and mentorship, and a strong interest in
	functional programming and type systems, Huw decided to apply these
	principles to machine learning - bringing together these diverse fields.</p>
    ",
    "details": "
	<p>Deep learning and deep neural networks are currently fields of great
	interest and excitement, due to their impressive results in supervised
	and unsupervised machine learning tasks across a broad range of fields
	including computer vision, speech recognition, and games such as Go.</p>

	<p>In this talk, I'll talk about my recent explorations in using type
	level and purely functional programming techniques applied to deep
	learning and neural networks.  We'll run over deep neural networks
	theory, their common architectures, and their various use cases to
	obtain an appreciation for the depth of the field. I'll then show
	how the use of modern Haskell programming allows for these networks
	to be expressed at the type level, providing not only extreme
	concision, but also compile time safety, functional reasoning and
	composition, as well as pretty good runtime performance with a high
	degree of confidence in their correctness.</p>
    "
  },

  {"time": "4:45pm",
    "name": "Jurriaan Hage",
    "id": "jurriaan-hage",
    "permalink": "/2017-melbourne/speaker-jurriaan-hage",
    "img": "/assets/img/2017-melbourne/jurriaan_hage.jpg",
    "level": 3,
    "title": "Domain-Specific Type Error Diagnosis in GHC",
    "bio": "
      <p>Jurriaan Hage is assistant professor at Utrecht University. His work in programming technology is largely focused 
        on two aspects: the optimisation of functional languages by means of type and effect systems, and type error 
        diagnosis for strongly typed functional languages. He is currently the lead maintainer of the Helium compiler 
        for learning Haskell. You can also talk to him about soft typing dynamic languages, program plagiarism 
        detection and switching classes.</p>
    ",
    "details": "
      <p>With its advanced type system, the purely functional language Haskell is extremely well-suited for 
         developing applications based on embedded domain specific languages (EDSL) for domains where the 
         quality of software is critical to success (e.g., the financial sector). To the compiler an EDSL 
         is no different from any other library written in Haskell; to the user of the EDSL, it is a library 
         that allows her to express her solution to a problem in her domain in a syntax (fluency) reminiscent 
         of that of the domain. But one problem continues to plague the end users of EDSLs: whenever a type 
         error occurs, the encoding of the domain inside the host language Haskell leaks out in those error message. 
         And this encoding is exactly what the EDSL developers were trying to hide! In this talk we demonstrate how 
         type error diagnosis can be made domain-specific by type level programming. We have implemented this in the 
         Glasgow Haskell Compiler, the industrial-strength compiler for Haskell. With relatively small modifications 
         to the compiler, we can show huge gains in terms of domain-aware type error messages, and 
         suggestions on how to fix a given type error. Our solution has more advantages: existing EDSLs can be 
         easily wrapped with specialized error diagnosis, the wrapping is invisible to the end user, and the 
         soundness of the type system is guaranteed by the compiler. The abstractions provided by type-level 
         programming allow us to describe and reuse common patterns in type error diagnosis, 
         lowering the entry barrier for DSL authors.</p> 


      <p>The talk will consist of an explanation and demonstration of what our technology, as implemented 
         in our branch of GHC, allows EDSL developers to do.</p> 
    "
  },
  {"time": "5:15pm",
    "name": "Keira Hodgkison",
    "id": "keira-hodgkison",
    "permalink": "/2017-melbourne/speaker-keira-hodgkison",
    "level": 2,
    "img": "/assets/img/2017-melbourne/keira_hodgkison.jpg",
    "title": "The Why and How of ReasonML. A Non-Functional Programmer's Perspective",
    "details": "

      <p> This talk is a general introduction to ReasonML and ReasonReact.
      Created by Facebook, ReasonML is a syntax layer and toolchain for OCaml
      and yet another compile-to-JavaScript, typed language. ReasonReact
      marries ReasonML's type-safety with the React component model while
      leveraging the existing ecosystem for developers seeking a better working
      experience across both web and native apps. </p>

      <p> Since its release in March 2017, the ReasonReact syntax has moved
      quickly. In this brief overview, attendees should gain an understanding
      of the the language's evolution, the ethos surrounding it and how it
      might shape development in the future. </p>
      ",
    "bio": "
      <p> Keira is a developer at Culture Amp, the world's leading culture
      analytics platform. She works with React, Flow, and Rails on solutions to
      help customers share, and act upon company employee engagement data.
      Keira is an advocate for using functional programming techniques to
      improve the JavaScript coding and refactoring experience. When she's not
      writing code, she can be found under a large cat. </p>
  "},
  {"time": "5:45pm",
    "id": "closing",
    "title": "Closing comment",
    "committee": true}

]}

